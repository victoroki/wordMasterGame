{"mappings":"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","sources":["game/script.js"],"sourcesContent":["const ANSWER_LENGTH = 5;\nconst ROUNDS = 6;\nconst letters = document.querySelectorAll(\".scoreboard-letter\");\nconst loadingDiv = document.querySelector(\".info-bar\");\n\n// I like to do an init function so I can use \"await\"\nasync function init() {\n  // the state for the app\n  let currentRow = 0;\n  let currentGuess = \"\";\n  let done = false;\n  let isLoading = true;\n\n  // nab the word of the day\n  const res = await fetch(\"https://words.dev-apis.com/word-of-the-day\");\n  const { word: wordRes } = await res.json();\n  const word = wordRes.toUpperCase();\n  const wordParts = word.split(\"\");\n  isLoading = false;\n  setLoading(isLoading);\n\n  // user adds a letter to the current guess\n  function addLetter(letter) {\n    if (currentGuess.length < ANSWER_LENGTH) {\n      currentGuess += letter;\n    } else {\n      current = currentGuess.substring(0, currentGuess.length - 1) + letter;\n    }\n\n    letters[currentRow * ANSWER_LENGTH + currentGuess.length - 1].innerText =\n      letter;\n  }\n\n  // use tries to enter a guess\n  async function commit() {\n    if (currentGuess.length !== ANSWER_LENGTH) {\n      // do nothing\n      return;\n    }\n\n    // check the API to see if it's a valid word\n    // skip this step if you're not checking for valid words\n    isLoading = true;\n    setLoading(isLoading);\n    const res = await fetch(\"https://words.dev-apis.com/validate-word\", {\n      method: \"POST\",\n      body: JSON.stringify({ word: currentGuess }),\n    });\n    const { validWord } = await res.json();\n    isLoading = false;\n    setLoading(isLoading);\n\n    // not valid, mark the word as invalid and return\n    if (!validWord) {\n      markInvalidWord();\n      return;\n    }\n\n    const guessParts = currentGuess.split(\"\");\n    const map = makeMap(wordParts);\n    let allRight = true;\n\n    // first pass just finds correct letters so we can mark those as\n    // correct first\n    for (let i = 0; i < ANSWER_LENGTH; i++) {\n      if (guessParts[i] === wordParts[i]) {\n        // mark as correct\n        letters[currentRow * ANSWER_LENGTH + i].classList.add(\"correct\");\n        map[guessParts[i]]--;\n      }\n    }\n\n    // second pass finds close and wrong letters\n    // we use the map to make sure we mark the correct amount of\n    // close letters\n    for (let i = 0; i < ANSWER_LENGTH; i++) {\n      if (guessParts[i] === wordParts[i]) {\n        // do nothing\n      } else if (map[guessParts[i]] && map[guessParts[i]] > 0) {\n        // mark as close\n        allRight = false;\n        letters[currentRow * ANSWER_LENGTH + i].classList.add(\"close\");\n        map[guessParts[i]]--;\n      } else {\n        // wrong\n        allRight = false;\n        letters[currentRow * ANSWER_LENGTH + i].classList.add(\"wrong\");\n      }\n    }\n\n    currentRow++;\n    currentGuess = \"\";\n    if (allRight) {\n      // win\n      alert(\"you win\");\n      document.querySelector(\".brand\").classList.add(\"winner\");\n      done = true;\n    } else if (currentRow === ROUNDS) {\n      // lose\n      alert(`you lose, the word was ${word}`);\n      done = true;\n    }\n  }\n\n  // user hits backspace, if the the length of the string is 0 then do\n  // nothing\n  function backspace() {\n    currentGuess = currentGuess.substring(0, currentGuess.length - 1);\n    letters[currentRow * ANSWER_LENGTH + currentGuess.length].innerText = \"\";\n  }\n\n  // let the user know that their guess wasn't a real word\n  // skip this if you're not doing guess validation\n  function markInvalidWord() {\n    for (let i = 0; i < ANSWER_LENGTH; i++) {\n      letters[currentRow * ANSWER_LENGTH + i].classList.remove(\"invalid\");\n\n      // long enough for the browser to repaint without the \"invalid class\" so we can then add it again\n      setTimeout(\n        () => letters[currentRow * ANSWER_LENGTH + i].classList.add(\"invalid\"),\n        10\n      );\n    }\n  }\n\n  // listening for event keys and routing to the right function\n  // we listen on keydown so we can catch Enter and Backspace\n  document.addEventListener(\"keydown\", function handleKeyPress(event) {\n    if (done || isLoading) {\n      // do nothing;\n      return;\n    }\n\n    const action = event.key;\n\n    if (action === \"Enter\") {\n      commit();\n    } else if (action === \"Backspace\") {\n      backspace();\n    } else if (isLetter(action)) {\n      addLetter(action.toUpperCase());\n    } else {\n      // do nothing\n    }\n  });\n}\n\n// a little function to check to see if a character is alphabet letter\n// this uses regex (the /[a-zA-Z]/ part) but don't worry about it\n// you can learn that later and don't need it too frequently\nfunction isLetter(letter) {\n  return /^[a-zA-Z]$/.test(letter);\n}\n\n// show the loading spinner when needed\nfunction setLoading(isLoading) {\n  loadingDiv.classList.toggle(\"hidden\", !isLoading);\n}\n\n// takes an array of letters (like ['E', 'L', 'I', 'T', 'E']) and creates\n// an object out of it (like {E: 2, L: 1, T: 1}) so we can use that to\n// make sure we get the correct amount of letters marked close instead\n// of just wrong or correct\nfunction makeMap(array) {\n  const obj = {};\n  for (let i = 0; i < array.length; i++) {\n    if (obj[array[i]]) {\n      obj[array[i]]++;\n    } else {\n      obj[array[i]] = 1;\n    }\n  }\n  return obj;\n}\n\ninit();"],"names":[],"version":3,"file":"index.972d9389.js.map","sourceRoot":"/__parcel_source_root/"}